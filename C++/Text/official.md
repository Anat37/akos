# Pflfybt eghjotyysq markdown

## Общее описание

Требуется написать программу на языке С++, использующую парадигму ООП, отображающую на экране форматированный текст. 
В аргументах командной строки задаются параметры, влияющие на стиль отображения текста.

Для разбора параметов необходимо использовать функцию getopt или getopt_long Параметры указываются следующим образом:

1. -f имя файла с разметкой,
2. -w ширина экрана,
3. -t отступ для второй и последующих строк списка (число пробелов),
4. -m символ-маркер ненумерованного списка,
5. -r величина красной строки.
6. -h - выдача help с описанием поведения программы
7. -v - отображение версии программы

Здесь предполагается, что параметры по ключам -w,-t,-m,-r - не обязательны и если параметр не указан, то задаётся значение по умолчанию.
Возможно например определение ширины экрана при помощи системных вызовов fstat и ioctl (man tty_ioctl).

## Описание форматов

Размеченый текст состоит из абзацев. Существует четыре типа абзацев: 

* заголовки,
* нумерованные списки, 
* маркированные списки, 
  * вложеный список
  * еще уровень
    * нужно больше уровней!
* простые абзацы.

Абзацы отделяются друг от друга двумя и более переносами строк. Всюду внутри абзацев два пробельных символа подряд считаются одним пробелом.

Заголовок задаётся следующим образом:

\# Текст заголовка до конца строки

Заголовки могут быть нескольких уровней, уровень заголовка задаётся числом символов '#' подряд в начале.

Нумерованные списки (число перед точкой не играет роли):

100. первый элемент списка
  1. первый элемент второй уровень списка
  2. второй элемент второй уровень списка
    3. первый элемент третий уровень списка
    4. второй элемент третий уровень списка
200. второй элемент списка

Маркированный список задаётся по аналогии с нумерованным, используется символ '*'.

Списки могут быть вложены друг в друга, вложенный список задаётся указанием отступа в 2 пробела
от предыдущего уровня.

Простые абзацы это все остальные абзацы. Чаще всего они будут начинаться просто с текста.

Примером разметки является текст с заданием.

## Описание способа отображения

Для размеченного текста, в соответствии с параметрами функции main требуется задать отображение на экран.

При отображении на экран все пробельные символы между словами должны быть заменены на один пробел (в памяти хранить именно в таком виде). 
В случае, если текст не помещается на одну строку, в него вставляются переносы. Запрещается, чтобы текст с переносами вылезал за границу 
ширины текста, также запрещается переносить так, чтобы на строчке оставался бы один символ. В случае невозможности поставить перенос 
строка завершается, а слово пишется на следующей строчке
(выдавать предупреждение и завершать программу если слово оказалось длиннее отображаемой ширины текста).

Для списков в начале ставится либо маркер, либо число c точкой, далее через определённое число пробельных символов, 
отсчитываемых от начала экрана, идёт текст связанный с элементом списка. Если элемент списка не помещается в одну строчку,
то на следующей строчке так же ставятся пробельные символы, чтобы был эффект отступа от края (см. пример ниже).
Так продолжается до следующего элемента. На следующем элементе всё начинается по новой: мы ставим маркер 
или следующий номер в нумерации, пробельные символы и текст. Если список вложенный, то на каждую строчку ставится 
дополнительный отступ в соответствии с уровнем вложенности.

Заголовки отображаются по центру заданной ширины экрана. При этом заголовок заключается в коробочку из символов '#'. 
Левая и правая граница коробочки обрамляется в столько решёточек, какого уровня заголовок, а сверху и снизу отображается 
на всю ширину экрана строка из решёток. После заголовка обязательно должна быть отображена пустая строка.

Простые абзацы начинаются с отступа первой строки задаваемого числом пробелов. На остальных строках отступа уже нет.

## Требования к программному коду

Программный код должен быть написан на C++ и содержать абстрактный базовый класс Abstract_text, который содержит методы:

unsigned long int countSymbols() const = 0;
unsigned long int countWords() const = 0;
void print() const = 0;

Каждый логический элемент текста должен храниться как char*. Запрещается использовать классы std::string и std::vector.

Каждый класс должен быть описан в собственном модуле.

Требуется создать наследников данного класса, где каждый класс соответствует одному из типов абзацев в размеченном тексте.
В наследниках необходимо полностью определить интерфейс класса-родителя, которая будет осуществлять 
параметризованную печать текста.

В программе должен быть класс Text_viewer, в котором должны быть методы осуществляющие чтение текста из файла 
в хранилище текста и его распечатку на экран из хранилища. 
Хранилище текста - массив указателей на объекты Abstract_text.

После распечатки текста, в стандартный поток ошибок должно быть выведено число символов и число слов в исходном тексте,
при этом несколько идущих подряд пробельных символов являются одним сисмолом и служебные символы задающие разметку 
не участвуют в подсчёте числа символов и слов.

В случае невозможности отображения текста программа должна выдавать сообщение об ошибки с вразумительным описанием проблемы.